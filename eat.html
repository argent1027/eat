<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"> <!-- IE自動更新 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index,follow">
    <!--讓搜索引擎更容易找到網站 -->
    <meta name="description" content="">
    <!--網站描述-->
    <meta name="author" content="Patrick">
    <!--作者-->
    <title>讓轉盤決定要吃什麼！</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-wEmeIV1mKuiNpC+IOBjI7aAzPcEZeedi5yW5f2yOq55WWLwNGmvvx4Um1vskeMj0" crossorigin="anonymous">
    <link rel="icon" href="/icon.png" type="image/x-icon" />
</head>

<style>
    body,
    ul,
    ol,
    li,
    p,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    form,
    fieldset,
    table,
    td,
    img,
    div {
        margin: 0;
        padding: 0;
        border: 0;
    }

    body {
        color: #333;
        font-size: 12px;
        font-family: "Microsoft YaHei"
    }

    ul,
    ol {
        list-style-type: none;
    }

    select,
    input,
    img,
    select {
        vertical-align: middle;
    }

    input {
        font-size: 12px;
    }

    a {
        text-decoration: none;
        color: #000;
    }

    a:hover {
        color: #c00;
        text-decoration: none;
    }

    .clear {
        clear: both;
    }

    /* 大转盘样式 */
    .banner {
        display: block;
        width: 130%;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: 20px;
    }

    .banner .turnplate {
        display: block;
        width: 100%;
        position: relative;
    }

    .banner .turnplate canvas.item {
        width: 100%;
    }

    .banner .turnplate img.pointer {
        position: absolute;
        width: 31.5%;
        height: 42.5%;
        left: 34.6%;
        top: 23%;
    }

    .bigcontean {
        display: flex;
        justify-content: center;
        flex-direction: row;
        flex-wrap: wrap;

    }

    .text {
        margin-left: 200px;

    }

    .top {
        padding-bottom: 50px;
    }
</style>

<body>
    <div align="center" class="top">
        <font size="60" align="center">今天吃什麼</font>
    </div>
    <div class="bigcontean">

        <div>
            <img src="https://i.ibb.co/NWwK6t1/1.png" id="shan-img" style="display:none;" />
            <img src="https://i.ibb.co/FY8gstm/2.png" id="sorry-img" style="display:none;" />
            <div class="banner">
                <div class="turnplate"
                    style="background-image:url(https://i.ibb.co/XDJmvHn/turnplate-bg.png);background-size:100% 100%;">
                    <canvas class="item" id="wheelcanvas" width="422px" height="422px"></canvas>
                    <img class="pointer" src="eat.png" />
                </div>
            </div>
        </div>


        <div class="text hei">
            <font size="3">第1間餐廳 </font><input type="text" class="form-control" id="index1" size=30 value="又一村"><br>
            <font size="3">第2間餐廳 </font><input type="text" class="form-control" id="index2" size=30 value="麵疙瘩"><br>
            <font size="3">第3間餐廳 </font><input type="text" class="form-control" id="index3" size=30 value="麥當勞"><br>
            <font size="3">第4間餐廳 </font><input type="text" class="form-control" id="index4" size=30 value="和園"><br>
            <font size="3">第5間餐廳 </font><input type="text" class="form-control" id="index5" size=30 value="叉燒麵"><br>
            <font size="3">第6間餐廳 </font><input type="text" class="form-control" id="index6" size=30 value="7-11"><br>
            <font size="3">第7間餐廳 </font><input type="text" class="form-control" id="index7" size=30><br>
            <font size="3">第8間餐廳 </font><input type="text" class="form-control" id="index8" size=30><br>
            <font size="3">第9間餐廳 </font><input type="text" class="form-control" id="index9" size=30><br>
            <font size="3">第10間餐廳 </font><input type="text" class="form-control" id="index10" size=30><br>

        </div>

    </div>






</body>

<script type="text/javascript">

    document.getElementById('index1').addEventListener('blur', render, false);
    document.getElementById('index2').addEventListener('blur', render, false);
    document.getElementById('index3').addEventListener('blur', render, false);
    document.getElementById('index4').addEventListener('blur', render, false);
    document.getElementById('index5').addEventListener('blur', render, false);
    document.getElementById('index6').addEventListener('blur', render, false);
    document.getElementById('index7').addEventListener('blur', render, false);
    document.getElementById('index8').addEventListener('blur', render, false);
    document.getElementById('index9').addEventListener('blur', render, false);
    document.getElementById('index10').addEventListener('blur', render, false);


    (function ($) {

        var supportedCSS, styles = document.getElementsByTagName("head")[0].style, toCheck = "transformProperty WebkitTransform OTransform msTransform MozTransform".split(" ");
        for (var a = 0; a < toCheck.length; a++) if (styles[toCheck[a]] !== undefined) supportedCSS = toCheck[a];
        // Bad eval to preven google closure to remove it from code o_O
        // After compresion replace it back to var IE = 'v' == '\v'
        var IE = eval('"v"=="\v"');

        jQuery.fn.extend({
            rotate: function (parameters) {
                if (this.length === 0 || typeof parameters == "undefined") return;
                if (typeof parameters == "number") parameters = { angle: parameters };
                var returned = [];
                for (var i = 0, i0 = this.length; i < i0; i++) {
                    var element = this.get(i);
                    if (!element.Wilq32 || !element.Wilq32.PhotoEffect) {

                        var paramClone = $.extend(true, {}, parameters);
                        var newRotObject = new Wilq32.PhotoEffect(element, paramClone)._rootObj;

                        returned.push($(newRotObject));
                    }
                    else {
                        element.Wilq32.PhotoEffect._handleRotation(parameters);
                    }
                }
                return returned;
            },
            getRotateAngle: function () {
                var ret = [];
                for (var i = 0, i0 = this.length; i < i0; i++) {
                    var element = this.get(i);
                    if (element.Wilq32 && element.Wilq32.PhotoEffect) {
                        ret[i] = element.Wilq32.PhotoEffect._angle;
                    }
                }
                return ret;
            },
            stopRotate: function () {
                for (var i = 0, i0 = this.length; i < i0; i++) {
                    var element = this.get(i);
                    if (element.Wilq32 && element.Wilq32.PhotoEffect) {
                        clearTimeout(element.Wilq32.PhotoEffect._timer);
                    }
                }
            }
        });

        // Library agnostic interface

        Wilq32 = window.Wilq32 || {};
        Wilq32.PhotoEffect = (function () {

            if (supportedCSS) {
                return function (img, parameters) {
                    img.Wilq32 = {
                        PhotoEffect: this
                    };

                    this._img = this._rootObj = this._eventObj = img;
                    this._handleRotation(parameters);
                }
            } else {
                return function (img, parameters) {
                    // Make sure that class and id are also copied - just in case you would like to refeer to an newly created object
                    this._img = img;

                    this._rootObj = document.createElement('span');
                    this._rootObj.style.display = "inline-block";
                    this._rootObj.Wilq32 =
                    {
                        PhotoEffect: this
                    };
                    img.parentNode.insertBefore(this._rootObj, img);

                    if (img.complete) {
                        this._Loader(parameters);
                    } else {
                        var self = this;
                        // TODO: Remove jQuery dependency
                        jQuery(this._img).bind("load", function () {
                            self._Loader(parameters);
                        });
                    }
                }
            }
        })();

        Wilq32.PhotoEffect.prototype = {
            _setupParameters: function (parameters) {
                this._parameters = this._parameters || {};
                if (typeof this._angle !== "number") this._angle = 0;
                if (typeof parameters.angle === "number") this._angle = parameters.angle;
                this._parameters.animateTo = (typeof parameters.animateTo === "number") ? (parameters.animateTo) : (this._angle);

                this._parameters.step = parameters.step || this._parameters.step || null;
                this._parameters.easing = parameters.easing || this._parameters.easing || function (x, t, b, c, d) { return -c * ((t = t / d - 1) * t * t * t - 1) + b; }
                this._parameters.duration = parameters.duration || this._parameters.duration || 1000;
                this._parameters.callback = parameters.callback || this._parameters.callback || function () { };
                if (parameters.bind && parameters.bind != this._parameters.bind) this._BindEvents(parameters.bind);
            },
            _handleRotation: function (parameters) {
                this._setupParameters(parameters);
                if (this._angle == this._parameters.animateTo) {
                    this._rotate(this._angle);
                }
                else {
                    this._animateStart();
                }
            },

            _BindEvents: function (events) {
                if (events && this._eventObj) {
                    // Unbinding previous Events
                    if (this._parameters.bind) {
                        var oldEvents = this._parameters.bind;
                        for (var a in oldEvents) if (oldEvents.hasOwnProperty(a))
                            // TODO: Remove jQuery dependency
                            jQuery(this._eventObj).unbind(a, oldEvents[a]);
                    }

                    this._parameters.bind = events;
                    for (var a in events) if (events.hasOwnProperty(a))
                        // TODO: Remove jQuery dependency
                        jQuery(this._eventObj).bind(a, events[a]);
                }
            },

            _Loader: (function () {
                if (IE)
                    return function (parameters) {
                        var width = this._img.width;
                        var height = this._img.height;
                        this._img.parentNode.removeChild(this._img);

                        this._vimage = this.createVMLNode('image');
                        this._vimage.src = this._img.src;
                        this._vimage.style.height = height + "px";
                        this._vimage.style.width = width + "px";
                        this._vimage.style.position = "absolute"; // FIXES IE PROBLEM - its only rendered if its on absolute position!
                        this._vimage.style.top = "0px";
                        this._vimage.style.left = "0px";

                        /* Group minifying a small 1px precision problem when rotating object */
                        this._container = this.createVMLNode('group');
                        this._container.style.width = width;
                        this._container.style.height = height;
                        this._container.style.position = "absolute";
                        this._container.setAttribute('coordsize', width - 1 + ',' + (height - 1)); // This -1, -1 trying to fix ugly problem with small displacement on IE
                        this._container.appendChild(this._vimage);

                        this._rootObj.appendChild(this._container);
                        this._rootObj.style.position = "relative"; // FIXES IE PROBLEM
                        this._rootObj.style.width = width + "px";
                        this._rootObj.style.height = height + "px";
                        this._rootObj.setAttribute('id', this._img.getAttribute('id'));
                        this._rootObj.className = this._img.className;
                        this._eventObj = this._rootObj;
                        this._handleRotation(parameters);
                    }
                else
                    return function (parameters) {
                        this._rootObj.setAttribute('id', this._img.getAttribute('id'));
                        this._rootObj.className = this._img.className;

                        this._width = this._img.width;
                        this._height = this._img.height;
                        this._widthHalf = this._width / 2; // used for optimisation
                        this._heightHalf = this._height / 2;// used for optimisation

                        var _widthMax = Math.sqrt((this._height) * (this._height) + (this._width) * (this._width));

                        this._widthAdd = _widthMax - this._width;
                        this._heightAdd = _widthMax - this._height;	// widthMax because maxWidth=maxHeight
                        this._widthAddHalf = this._widthAdd / 2; // used for optimisation
                        this._heightAddHalf = this._heightAdd / 2;// used for optimisation

                        this._img.parentNode.removeChild(this._img);

                        this._aspectW = ((parseInt(this._img.style.width, 10)) || this._width) / this._img.width;
                        this._aspectH = ((parseInt(this._img.style.height, 10)) || this._height) / this._img.height;

                        this._canvas = document.createElement('canvas');
                        this._canvas.setAttribute('width', this._width);
                        this._canvas.style.position = "relative";
                        this._canvas.style.left = -this._widthAddHalf + "px";
                        this._canvas.style.top = -this._heightAddHalf + "px";
                        this._canvas.Wilq32 = this._rootObj.Wilq32;

                        this._rootObj.appendChild(this._canvas);
                        this._rootObj.style.width = this._width + "px";
                        this._rootObj.style.height = this._height + "px";
                        this._eventObj = this._canvas;

                        this._cnv = this._canvas.getContext('2d');
                        this._handleRotation(parameters);
                    }
            })(),

            _animateStart: function () {
                if (this._timer) {
                    clearTimeout(this._timer);
                }
                this._animateStartTime = +new Date;
                this._animateStartAngle = this._angle;
                this._animate();
            },
            _animate: function () {
                var actualTime = +new Date;
                var checkEnd = actualTime - this._animateStartTime > this._parameters.duration;

                // TODO: Bug for animatedGif for static rotation ? (to test)
                if (checkEnd && !this._parameters.animatedGif) {
                    clearTimeout(this._timer);
                }
                else {
                    if (this._canvas || this._vimage || this._img) {
                        var angle = this._parameters.easing(0, actualTime - this._animateStartTime, this._animateStartAngle, this._parameters.animateTo - this._animateStartAngle, this._parameters.duration);
                        this._rotate((~~(angle * 10)) / 10);
                    }
                    if (this._parameters.step) {
                        this._parameters.step(this._angle);
                    }
                    var self = this;
                    this._timer = setTimeout(function () {
                        self._animate.call(self);
                    }, 10);
                }

                // To fix Bug that prevents using recursive function in callback I moved this function to back
                if (this._parameters.callback && checkEnd) {
                    this._angle = this._parameters.animateTo;
                    this._rotate(this._angle);
                    this._parameters.callback.call(this._rootObj);
                }
            },

            _rotate: (function () {
                var rad = Math.PI / 180;
                if (IE)
                    return function (angle) {
                        this._angle = angle;
                        this._container.style.rotation = (angle % 360) + "deg";
                    }
                else if (supportedCSS)
                    return function (angle) {
                        this._angle = angle;
                        this._img.style[supportedCSS] = "rotate(" + (angle % 360) + "deg)";
                    }
                else
                    return function (angle) {
                        this._angle = angle;
                        angle = (angle % 360) * rad;
                        // clear canvas	
                        this._canvas.width = this._width + this._widthAdd;
                        this._canvas.height = this._height + this._heightAdd;

                        // REMEMBER: all drawings are read from backwards.. so first function is translate, then rotate, then translate, translate..
                        this._cnv.translate(this._widthAddHalf, this._heightAddHalf);	// at least center image on screen
                        this._cnv.translate(this._widthHalf, this._heightHalf);			// we move image back to its orginal 
                        this._cnv.rotate(angle);										// rotate image
                        this._cnv.translate(-this._widthHalf, -this._heightHalf);		// move image to its center, so we can rotate around its center
                        this._cnv.scale(this._aspectW, this._aspectH); // SCALE - if needed ;)
                        this._cnv.drawImage(this._img, 0, 0);							// First - we draw image
                    }

            })()
        }

        if (IE) {
            Wilq32.PhotoEffect.prototype.createVMLNode = (function () {
                document.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
                try {
                    !document.namespaces.rvml && document.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                    return function (tagName) {
                        return document.createElement('<rvml:' + tagName + ' class="rvml">');
                    };
                } catch (e) {
                    return function (tagName) {
                        return document.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                    };
                }
            })();
        }
    })(jQuery);


    // 從這裡開始
    var turnplate = {
        restaraunts: [],			//轉盤獎品名稱
        colors: [],					//大轉盤獎品區塊對應顏色
        outsideRadius: 192,			//大轉盤外圈半徑
        textRadius: 155,			//大轉盤獎品位置距離圓心的距離
        insideRadius: 68,			//大轉盤內圓半徑
        startAngle: 0,				//開始角度
        bRotate: false				//false:停止;ture:旋轉
    };

    function render() {
        var array = new Array;
        for (i = 1; i <= 10; i++) {
            var key = "index" + i;
            var value = document.getElementById(key).value.trim();
            value = value.toString();
            if (value != "" || value != "" || value != "") {
                array.push(value)
            }
        }
        console.log(array);
        turnplate.restaraunts = array;
        turnplate.colors = ["#FFF4D6", "#FFFFFF", "#FFF4D6", "#FFFFFF", "#FFF4D6", "#FFFFFF", "#FFF4D6", "#FFFFFF", "#FFF4D6", "#FFFFFF"];
        var item = rnd(1, turnplate.restaraunts.length);

        drawRouletteWheel();


    }

    $(document).ready(function () {

        //旋轉轉盤 item:獎品位置; txt：提示语;
        var rotateFn = function (item, txt) {
            var angles = item * (360 / turnplate.restaraunts.length) - (360 / (turnplate.restaraunts.length * 2));
            if (angles < 270) {
                angles = 270 - angles;
            } else {
                angles = 360 - angles + 270;
            }
            $('#wheelcanvas').stopRotate();
            $('#wheelcanvas').rotate({
                angle: 0,
                animateTo: angles + 1800,
                duration: 8000,
                callback: function () {
                    alert("今天吃" + txt);
                    turnplate.bRotate = !turnplate.bRotate;
                }
            });
        };

        $('.pointer').click(function () {
            if (turnplate.bRotate) return;
            turnplate.bRotate = !turnplate.bRotate;
            //獲取隨機數
            var item = rnd(1, turnplate.restaraunts.length);

            //獎品數量等於10,指針落在對應獎品區域中心角度[252, 216, 180, 144, 108, 72, 36, 360, 324, 288]
            rotateFn(item, turnplate.restaraunts[item - 1]);
            console.log(item);
        });
    });

    $(function () {
        render();
    })

    function rnd(n, m) {
        var random = Math.floor(Math.random() * (m - n + 1) + n);
        return random;

    }

    //頁面所有元素加載完畢後執行drawRouletteWheel() 方法對轉盤進行渲染
    window.onload = function () {
        drawRouletteWheel();
    };

    function drawRouletteWheel() {
        var canvas = document.getElementById("wheelcanvas");
        if (canvas.getContext) {
            //根据奖品个数计算圆周角度
            var arc = Math.PI / (turnplate.restaraunts.length / 2);
            var ctx = canvas.getContext("2d");
            //在给定矩形内清空一个矩形
            ctx.clearRect(0, 0, 422, 422);
            //strokeStyle 属性设置或返回用于笔触的颜色、渐变或模式  
            ctx.strokeStyle = "#FFBE04";
            //font 属性设置或返回画布上文本内容的当前字体属性
            ctx.font = '16px Microsoft YaHei';
            for (var i = 0; i < turnplate.restaraunts.length; i++) {
                var angle = turnplate.startAngle + i * arc;
                ctx.fillStyle = turnplate.colors[i];
                ctx.beginPath();
                //arc(x,y,r,起始角,结束角,绘制方向) 方法创建弧/曲线（用于创建圆或部分圆）    
                ctx.arc(211, 211, turnplate.outsideRadius, angle, angle + arc, false);
                ctx.arc(211, 211, turnplate.insideRadius, angle + arc, angle, true);
                ctx.stroke();
                ctx.fill();
                //锁画布(为了保存之前的画布状态)
                ctx.save();

                //----绘制奖品开始----
                ctx.fillStyle = "#E5302F";
                var text = turnplate.restaraunts[i];
                var line_height = 17;
                //translate方法重新映射画布上的 (0,0) 位置
                ctx.translate(211 + Math.cos(angle + arc / 2) * turnplate.textRadius, 211 + Math.sin(angle + arc / 2) * turnplate.textRadius);

                //rotate方法旋转当前的绘图
                ctx.rotate(angle + arc / 2 + Math.PI / 2);

                /** 下面代码根据奖品类型、奖品名称长度渲染不同效果，如字体、颜色、图片效果。(具体根据实际情况改变) **/
                if (text.indexOf("M") > 0) {//流量包
                    var texts = text.split("M");
                    for (var j = 0; j < texts.length; j++) {
                        ctx.font = j == 0 ? 'bold 20px Microsoft YaHei' : '16px Microsoft YaHei';
                        if (j == 0) {
                            ctx.fillText(texts[j] + "M", -ctx.measureText(texts[j] + "M").width / 2, j * line_height);
                        } else {
                            ctx.fillText(texts[j], -ctx.measureText(texts[j]).width / 2, j * line_height);
                        }
                    }
                } else if (text.indexOf("M") == -1 && text.length > 6) {//奖品名称长度超过一定范围 
                    text = text.substring(0, 6) + "||" + text.substring(6);
                    var texts = text.split("||");
                    for (var j = 0; j < texts.length; j++) {
                        ctx.fillText(texts[j], -ctx.measureText(texts[j]).width / 2, j * line_height);
                    }
                } else {
                    //在画布上绘制填色的文本。文本的默认颜色是黑色
                    //measureText()方法返回包含一个对象，该对象包含以像素计的指定字体宽度
                    ctx.fillText(text, -ctx.measureText(text).width / 2, 0);
                }

                //添加对应图标
                if (text.indexOf("闪币") > 0) {
                    var img = document.getElementById("shan-img");
                    img.onload = function () {
                        ctx.drawImage(img, -15, 10);
                    };
                    ctx.drawImage(img, -15, 10);
                } else if (text.indexOf("謝謝參加") >= 0) {
                    var img = document.getElementById("sorry-img");
                    img.onload = function () {
                        ctx.drawImage(img, -15, 10);
                    };
                    ctx.drawImage(img, -15, 10);
                }
                //把当前画布返回（调整）到上一个save()状态之前 
                ctx.restore();

            }
        }
    }


</script>


</html>